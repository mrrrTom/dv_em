# ToDo: resolve all types in all classes

program: {
  shape: class
  main(arg int): (result int)
}

emulator: {
  shape: class

  -_commandsStore: kernelCommandsStore

  +ctor(char\* configPath, char\* codePath)
  +run()
  +process(char symb, int\* args)
  +stop()
  -destructor()
}

emulator -> program: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

configuration\<adressT\>: {
  shape: class

  +memory_model: cellSheme
  +registers_model: "registerScheme[]"
  +start_beat: std::string
  +beat: std::strig
  +commands: std::unordered_map<std::string, std::string>
}

registerScheme: {
  shape: class
  +name: std::string # key
  +comment: std::string
  +size: unsigned char # 0 -> 256
}

cellScheme: {
  shape: class
  # all invariants must be written down  
  +adress_size: unsigned char
  +command_first_bit: unsigned short int
  +command_last_bit: unsigned short int
  +arguments_firts_bit: unsigned short int
  +arguments_last_bit: unsigned short int
  +fixed_operand_size: bool
  +operand_size: unsigned short int
}

registerScheme -> configuration: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

cellScheme -> configuration: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

configuration -> emulator: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

kernelCommandsStore: {
  shape: class

  resolveCommand(int commandBits): void (*) (int* args, memoryManager mm, registersManager rm, executor e)
}

emulator -> kernelCommandsStore: uses

kernelCommandsStore -> executor: uses

view: {
  shape: class
}

view -> emulator: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

memoryManager: {
  shape: class
  write(byte int): (result bool)
  read(): (resutl int)
  getCursorPosition()
  setCursorPostion()
  enumerate(): (cells iterator<cell>)
}

memoryManager -> emulator: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

cell: {
  shape: class
  field: _commandResolver
  field: _argumentsResolver

  field: _adressSize
  field: adress
  field: cellSize # bits
  field: bits # max number (need compile time check for configuration)

  resolveCommand(): (cmd int)
  resolveArguments(): (args int)
}

cell -> memoryManager: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

registersManager: {
  shape: class
}

registersManager -> emulator: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

pregister: {
  shape: class
}

pregister -> registersManager: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

executor: {
  shape: class
  run() # run through all memory & execute every cell command
  execute(int commandBits)
}

userCommandsStore: {
  shape: class
  resolveCommand(int commandBits): void (*) (int* args, memoryManager mm, registersManager rm)
}

userCommandsStore -> memoryManager: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

userCommandsStore -> registersManager: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

executor -> userCommandsStore: uses

executor -> emulator: {
  target-arrowhead: {
    shape: diamond
    style.filled: true
  }
}

executor -> memoryManager: uses
executor -> registersManager: uses

parser: {
  shape: class
}
